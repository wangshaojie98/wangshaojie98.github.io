(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{201:function(a,t,e){a.exports=e.p+"assets/img/image2.9efafd97.png"},202:function(a,t,e){a.exports=e.p+"assets/img/image1.1438db5c.png"},212:function(a,t,e){"use strict";e.r(t);var r=e(0),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"react新的前端思维方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react新的前端思维方式","aria-hidden":"true"}},[a._v("#")]),a._v(" React新的前端思维方式")]),a._v(" "),r("p",[a._v("深入浅出react与redux第一章，主要认识一下react.")]),a._v(" "),r("h2",{attrs:{id:"初始化一个react项目"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#初始化一个react项目","aria-hidden":"true"}},[a._v("#")]),a._v(" 初始化一个React项目")]),a._v(" "),r("p",[a._v("通过全局安装"),r("code",[a._v("create-react-app")]),a._v("工具")]),a._v(" "),r("ol",[r("li",[r("code",[a._v("npm install --global create-react-app")]),a._v(" / "),r("code",[a._v("yarn global add create-react-app")])]),a._v(" "),r("li",[r("code",[a._v("create-react-app first_react_app")]),a._v(" 创建一个名为first_react_app的项目")])]),a._v(" "),r("p",[a._v("也可以不用全局安装，这里使用"),r("code",[a._v("npx")]),a._v("命令")]),a._v(" "),r("h3",{attrs:{id:"npx第一种用法-调用项目安装的模块"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#npx第一种用法-调用项目安装的模块","aria-hidden":"true"}},[a._v("#")]),a._v(" npx第一种用法--调用项目安装的模块")]),a._v(" "),r("p",[a._v("npx 会帮你执行依赖包里的二进制文件")]),a._v(" "),r("p",[r("img",{attrs:{src:e(201),alt:"可执行的bin目录"}})]),a._v(" "),r("p",[a._v("举个例子，以前我们用webpcak可能是这样")]),a._v(" "),r("div",{staticClass:"language-bash extra-class"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[r("span",{pre:!0,attrs:{class:"token function"}},[a._v("npm")]),a._v(" i -D webpack\n./node_modules/.bin/webpack -v //会找到相应目录下的webpack可执行文件\n// "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("4.41")]),a._v(".2\n")])])]),r("p",[a._v("而现在有了npx可以这样写")]),a._v(" "),r("div",{staticClass:"language-bash extra-class"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[a._v("npx webpack -v // 自动帮你找到webpack可执行文件\n// "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("4.41")]),a._v(".2\n")])])]),r("p",[a._v("npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！")]),a._v(" "),r("h3",{attrs:{id:"npx第二种用法-避免全局安装模块"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#npx第二种用法-避免全局安装模块","aria-hidden":"true"}},[a._v("#")]),a._v(" npx第二种用法--避免全局安装模块")]),a._v(" "),r("p",[a._v("除了调用项目内部模块，npx 还能避免全局安装的模块。比如，"),r("code",[a._v("create-react-app")]),a._v("这个模块是全局安装，npx 可以运行它，而且不进行全局安装。")]),a._v(" "),r("div",{staticClass:"language-bash extra-class"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[a._v("npx create-react-app first_demo_app \n// 自动安装create-react-app,并且使用创建一个项目，然后自动删除\n")])])]),r("p",[a._v("npx 将"),r("code",[a._v("create-react-app")]),a._v("下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载"),r("code",[a._v("create-react-app")]),a._v("。")]),a._v(" "),r("p",[a._v("所以接着上面创建react项目的第二个方法是")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("npx create-react-app demo-app\n")])])]),r("h2",{attrs:{id:"react组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react组件","aria-hidden":"true"}},[a._v("#")]),a._v(" React组件")]),a._v(" "),r("p",[a._v("React的首要思想是通过组件来开发应用。指的是完成某个特定功能的独立的、可重用的代码。")]),a._v(" "),r("p",[a._v("为什么没有用到React还要引入？")]),a._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" React "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[a._v("'react'")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),r("p",[a._v("如果将其删掉会报错 // “在使用JSX范围内必须有React”.")]),a._v(" "),r("p",[a._v("也就是说，在使用JSX代码的地方，必须引入React,即使没有显式调用，也要导入，因为JSX最终会被转译成以来于React的表达式。")]),a._v(" "),r("h3",{attrs:{id:"jsx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jsx","aria-hidden":"true"}},[a._v("#")]),a._v(" JSX")]),a._v(" "),r("p",[a._v("JavaScript extension,让我们可以在JS中编写像HTML一样的代码。")]),a._v(" "),r("h3",{attrs:{id:"如何判断一个元素是组件还是html"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何判断一个元素是组件还是html","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何判断一个元素是组件还是HTML?")]),a._v(" "),r("p",[a._v("React判断一个元素是HTML还是React组件原则是看第一个字母是否是大写，如果在JSX我们不用ClickCount而用clickCount，那就不会得到正确结果。")]),a._v(" "),r("h3",{attrs:{id:"为什么react脱离了jquery那种绑定dom的写法还可以使用onclick这种？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么react脱离了jquery那种绑定dom的写法还可以使用onclick这种？","aria-hidden":"true"}},[a._v("#")]),a._v(" 为什么React脱离了JQuery那种绑定DOM的写法还可以使用OnClick这种？")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("首先,onClick挂载的每个函数，都可以控制在组件范围之内，不会污染全局。")])]),a._v(" "),r("li",[r("p",[a._v("我们在JSX中组件使用的onClick，但并不是直接使用onclick的HTML，而是React在背后利用事件委托的方式，只在DOM树上添加一个事件函数，挂载顶层的DOM节点。然后利用时间处理函数捕获，具体组件分配特定的函数。")])]),a._v(" "),r("li",[r("p",[a._v("因为React控制了组件的生命周期，在unmount的时候自然会清楚相关的所有事件处理函数，内存泄漏不在是一个问题。")])])]),a._v(" "),r("h2",{attrs:{id:"react-script-应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-script-应用","aria-hidden":"true"}},[a._v("#")]),a._v(" React script 应用")]),a._v(" "),r("ol",[r("li",[r("code",[a._v("npm run start")]),a._v(" 本地开发测试使用")]),a._v(" "),r("li",[r("code",[a._v("npm run build")]),a._v(" 打包构建")]),a._v(" "),r("li",[r("code",[a._v("npm run eject")]),a._v(" 把配置项弹射出来，可以查看，但是操作是不可逆的。")])]),a._v(" "),r("div",{staticClass:"language-json extra-class"},[r("pre",{pre:!0,attrs:{class:"language-json"}},[r("code",[r("span",{pre:!0,attrs:{class:"token property"}},[a._v('"scripts"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token property"}},[a._v('"start"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[a._v('"react-scripts start"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token property"}},[a._v('"build"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[a._v('"react-scripts build"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token property"}},[a._v('"test"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[a._v('"react-scripts test --env=jsdom"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token property"}},[a._v('"eject"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[a._v('"react-scripts eject"')]),a._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),r("p",[a._v("首先我们执行命令其实是"),r("code",[a._v("npm run start")]),a._v("/ 简写为"),r("code",[a._v("npm start")]),a._v("，它其实执行的是"),r("code",[a._v("react-scripts start")]),a._v("命令。而这个命令执行的是下面一段"),r("code",[a._v("bash")])]),a._v(" "),r("p",[r("img",{attrs:{src:e(202),alt:""}})]),a._v(" "),r("h2",{attrs:{id:"react的工作方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react的工作方式","aria-hidden":"true"}},[a._v("#")]),a._v(" React的工作方式")]),a._v(" "),r("blockquote",[r("p",[r("em",[r("strong",[a._v("UI = render(data)")])])])]),a._v(" "),r("p",[a._v("公式表达的意思是用户看到的"),r("em",[a._v("UI")]),a._v("界面是"),r("code",[a._v("render")]),a._v("函数执行的结果，这个函数只接受"),r("code",[a._v("data")]),a._v("数据作为参数。"),r("code",[a._v("render")]),a._v("函树是一个"),r("strong",[a._v("纯函数")]),a._v("。如此一来"),r("strong",[a._v("UI")]),a._v("显示的内容完全取决于"),r("code",[a._v("data")]),a._v("。用户想要更新视图，只需要更新"),r("code",[a._v("data")]),a._v("即可。")]),a._v(" "),r("h3",{attrs:{id:"virtual-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom","aria-hidden":"true"}},[a._v("#")]),a._v(" Virtual DOM")]),a._v(" "),r("p",[a._v("既然React应用是重复渲染来实现用户交互，可能会有疑问这样重复渲染的效率会不会太低了？")]),a._v(" "),r("p",[a._v("毕竟JQuery中更改视图只是更改那一个变化的DOM。而React看样子是把整个组件重新更新了。事实上React利用")]),a._v(" "),r("p",[r("strong",[a._v("Virtual Dom")]),a._v("去更新节点，就不会造成"),r("em",[a._v("浪费")]),a._v("。")]),a._v(" "),r("p",[r("strong",[a._v("那就先了解一下DOM")])]),a._v(" "),r("p",[a._v('DOM是结构化文本的抽象表达式，特定于Web环境中，这个结构化文本就是HTML文本，HTML中的每个元素都对应一个DOM节点，这样HTML逐层包含的关系，就会形成一颗"'),r("em",[a._v("DOM树")]),a._v('"。')]),a._v(" "),r("p",[a._v("总的来说浏览器为了渲染HTML格式的网页，会先将HTML解析成DOM树，然后根据DOM树渲染用户的界面，当要改变界面内容时，就去改变DOM树上的节点。")]),a._v(" "),r("blockquote",[r("p",[a._v("web开发关于性能优化有一个原则：尽量减少操作DOM。")])]),a._v(" "),r("p",[r("strong",[a._v("回到虚拟DOM")])]),a._v(" "),r("p",[a._v("那么DOM树是对HTML的抽象，那么Virtual DOM 是对DOM树的抽象。Vitual DOM其实只是一个JavaScript对象形式的树形结构，并不直接操作DOM树，每次渲染时React会通过Virtual DOM树去对比两个JS树，找出变化的部分，然后修改真正的DOM树中的变化部分。")])])}),[],!1,null,null,null);t.default=s.exports}}]);