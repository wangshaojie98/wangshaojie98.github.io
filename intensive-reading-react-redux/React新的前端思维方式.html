<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React新的前端思维方式 | 梅格Drum</title>
    <meta name="description" content="Just playing around">
    <link rel="icon" href="/img/logo.ico">
  <link rel="mainfest" href="/manifest.json">
    
    <link rel="preload" href="/assets/css/0.styles.45b3d53f.css" as="style"><link rel="preload" href="/assets/js/app.5e2fb6a2.js" as="script"><link rel="preload" href="/assets/js/2.e64ac863.js" as="script"><link rel="preload" href="/assets/js/5.f67afb7f.js" as="script"><link rel="prefetch" href="/assets/js/10.06160dd2.js"><link rel="prefetch" href="/assets/js/3.41b3c96f.js"><link rel="prefetch" href="/assets/js/4.9dd03212.js"><link rel="prefetch" href="/assets/js/6.84d2832a.js"><link rel="prefetch" href="/assets/js/7.7e1505d7.js"><link rel="prefetch" href="/assets/js/8.c4d88ebe.js"><link rel="prefetch" href="/assets/js/9.b06fc0c6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.45b3d53f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">梅格Drum</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">Chinese</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">Japanese</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">Chinese</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">Japanese</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/intensive-reading-react-redux/" class="sidebar-link">精读深入浅出React与Redux</a></li><li><a href="/intensive-reading-react-redux/React新的前端思维方式.html" class="active sidebar-link">React新的前端思维方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/intensive-reading-react-redux/React新的前端思维方式.html#初始化一个react项目" class="sidebar-link">初始化一个React项目</a></li><li class="sidebar-sub-header"><a href="/intensive-reading-react-redux/React新的前端思维方式.html#react组件" class="sidebar-link">React组件</a></li><li class="sidebar-sub-header"><a href="/intensive-reading-react-redux/React新的前端思维方式.html#react-script-应用" class="sidebar-link">React script 应用</a></li><li class="sidebar-sub-header"><a href="/intensive-reading-react-redux/React新的前端思维方式.html#react的工作方式" class="sidebar-link">React的工作方式</a></li></ul></li><li><a href="/intensive-reading-react-redux/设计高质量的React组件.html" class="sidebar-link">设计高质量的React组件</a></li><li><a href="/intensive-reading-react-redux/React组件的性能优化.html" class="sidebar-link">React组件的性能优化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react新的前端思维方式"><a href="#react新的前端思维方式" aria-hidden="true" class="header-anchor">#</a> React新的前端思维方式</h1> <p>深入浅出react与redux第一章，主要认识一下react.</p> <h2 id="初始化一个react项目"><a href="#初始化一个react项目" aria-hidden="true" class="header-anchor">#</a> 初始化一个React项目</h2> <p>通过全局安装<code>create-react-app</code>工具</p> <ol><li><code>npm install --global create-react-app</code> / <code>yarn global add create-react-app</code></li> <li><code>create-react-app first_react_app</code> 创建一个名为first_react_app的项目</li></ol> <p>也可以不用全局安装，这里使用<code>npx</code>命令</p> <h3 id="npx第一种用法-调用项目安装的模块"><a href="#npx第一种用法-调用项目安装的模块" aria-hidden="true" class="header-anchor">#</a> npx第一种用法--调用项目安装的模块</h3> <p>npx 会帮你执行依赖包里的二进制文件</p> <p><img src="/assets/img/image2.9efafd97.png" alt="可执行的bin目录"></p> <p>举个例子，以前我们用webpcak可能是这样</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> i -D webpack
./node_modules/.bin/webpack -v //会找到相应目录下的webpack可执行文件
// <span class="token number">4.41</span>.2
</code></pre></div><p>而现在有了npx可以这样写</p> <div class="language-bash extra-class"><pre class="language-bash"><code>npx webpack -v // 自动帮你找到webpack可执行文件
// <span class="token number">4.41</span>.2
</code></pre></div><p>npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！</p> <h3 id="npx第二种用法-避免全局安装模块"><a href="#npx第二种用法-避免全局安装模块" aria-hidden="true" class="header-anchor">#</a> npx第二种用法--避免全局安装模块</h3> <p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，<code>create-react-app</code>这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>npx create-react-app first_demo_app 
// 自动安装create-react-app,并且使用创建一个项目，然后自动删除
</code></pre></div><p>npx 将<code>create-react-app</code>下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载<code>create-react-app</code>。</p> <p>所以接着上面创建react项目的第二个方法是</p> <div class="language- extra-class"><pre class="language-text"><code>npx create-react-app demo-app
</code></pre></div><h2 id="react组件"><a href="#react组件" aria-hidden="true" class="header-anchor">#</a> React组件</h2> <p>React的首要思想是通过组件来开发应用。指的是完成某个特定功能的独立的、可重用的代码。</p> <p>为什么没有用到React还要引入？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
</code></pre></div><p>如果将其删掉会报错 // “在使用JSX范围内必须有React”.</p> <p>也就是说，在使用JSX代码的地方，必须引入React,即使没有显式调用，也要导入，因为JSX最终会被转译成以来于React的表达式。</p> <h3 id="jsx"><a href="#jsx" aria-hidden="true" class="header-anchor">#</a> JSX</h3> <p>JavaScript extension,让我们可以在JS中编写像HTML一样的代码。</p> <h3 id="如何判断一个元素是组件还是html"><a href="#如何判断一个元素是组件还是html" aria-hidden="true" class="header-anchor">#</a> 如何判断一个元素是组件还是HTML?</h3> <p>React判断一个元素是HTML还是React组件原则是看第一个字母是否是大写，如果在JSX我们不用ClickCount而用clickCount，那就不会得到正确结果。</p> <h3 id="为什么react脱离了jquery那种绑定dom的写法还可以使用onclick这种？"><a href="#为什么react脱离了jquery那种绑定dom的写法还可以使用onclick这种？" aria-hidden="true" class="header-anchor">#</a> 为什么React脱离了JQuery那种绑定DOM的写法还可以使用OnClick这种？</h3> <ol><li><p>首先,onClick挂载的每个函数，都可以控制在组件范围之内，不会污染全局。</p></li> <li><p>我们在JSX中组件使用的onClick，但并不是直接使用onclick的HTML，而是React在背后利用事件委托的方式，只在DOM树上添加一个事件函数，挂载顶层的DOM节点。然后利用时间处理函数捕获，具体组件分配特定的函数。</p></li> <li><p>因为React控制了组件的生命周期，在unmount的时候自然会清楚相关的所有事件处理函数，内存泄漏不在是一个问题。</p></li></ol> <h2 id="react-script-应用"><a href="#react-script-应用" aria-hidden="true" class="header-anchor">#</a> React script 应用</h2> <ol><li><code>npm run start</code> 本地开发测试使用</li> <li><code>npm run build</code> 打包构建</li> <li><code>npm run eject</code> 把配置项弹射出来，可以查看，但是操作是不可逆的。</li></ol> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;start&quot;</span><span class="token operator">:</span> <span class="token string">&quot;react-scripts start&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;build&quot;</span><span class="token operator">:</span> <span class="token string">&quot;react-scripts build&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;test&quot;</span><span class="token operator">:</span> <span class="token string">&quot;react-scripts test --env=jsdom&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;eject&quot;</span><span class="token operator">:</span> <span class="token string">&quot;react-scripts eject&quot;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>首先我们执行命令其实是<code>npm run start</code>/ 简写为<code>npm start</code>，它其实执行的是<code>react-scripts start</code>命令。而这个命令执行的是下面一段<code>bash</code></p> <p><img src="/assets/img/image1.1438db5c.png" alt=""></p> <h2 id="react的工作方式"><a href="#react的工作方式" aria-hidden="true" class="header-anchor">#</a> React的工作方式</h2> <blockquote><p><em><strong>UI = render(data)</strong></em></p></blockquote> <p>公式表达的意思是用户看到的<em>UI</em>界面是<code>render</code>函数执行的结果，这个函数只接受<code>data</code>数据作为参数。<code>render</code>函树是一个<strong>纯函数</strong>。如此一来<strong>UI</strong>显示的内容完全取决于<code>data</code>。用户想要更新视图，只需要更新<code>data</code>即可。</p> <h3 id="virtual-dom"><a href="#virtual-dom" aria-hidden="true" class="header-anchor">#</a> Virtual DOM</h3> <p>既然React应用是重复渲染来实现用户交互，可能会有疑问这样重复渲染的效率会不会太低了？</p> <p>毕竟JQuery中更改视图只是更改那一个变化的DOM。而React看样子是把整个组件重新更新了。事实上React利用</p> <p><strong>Virtual Dom</strong>去更新节点，就不会造成<em>浪费</em>。</p> <p><strong>那就先了解一下DOM</strong></p> <p>DOM是结构化文本的抽象表达式，特定于Web环境中，这个结构化文本就是HTML文本，HTML中的每个元素都对应一个DOM节点，这样HTML逐层包含的关系，就会形成一颗&quot;<em>DOM树</em>&quot;。</p> <p>总的来说浏览器为了渲染HTML格式的网页，会先将HTML解析成DOM树，然后根据DOM树渲染用户的界面，当要改变界面内容时，就去改变DOM树上的节点。</p> <blockquote><p>web开发关于性能优化有一个原则：尽量减少操作DOM。</p></blockquote> <p><strong>回到虚拟DOM</strong></p> <p>那么DOM树是对HTML的抽象，那么Virtual DOM 是对DOM树的抽象。Vitual DOM其实只是一个JavaScript对象形式的树形结构，并不直接操作DOM树，每次渲染时React会通过Virtual DOM树去对比两个JS树，找出变化的部分，然后修改真正的DOM树中的变化部分。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/intensive-reading-react-redux/" class="prev router-link-active">精读深入浅出React与Redux</a></span> <span class="next"><a href="/intensive-reading-react-redux/设计高质量的React组件.html">设计高质量的React组件</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5e2fb6a2.js" defer></script><script src="/assets/js/2.e64ac863.js" defer></script><script src="/assets/js/5.f67afb7f.js" defer></script>
  </body>
</html>
